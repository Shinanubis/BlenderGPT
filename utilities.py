import bpy
import re
import os
import sys

# ==============================================================
# Load the bundled OpenAI dependency from /lib
# ==============================================================
libs_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "lib")
if libs_path not in sys.path:
    sys.path.append(libs_path)

try:
    from openai import OpenAI
except ImportError as e:
    print(f"‚ùå Failed to import OpenAI from {libs_path}: {e}")
    raise e


# ==============================================================
# BlenderGPT Utilities
# ==============================================================

def get_openai_credentials():
    """Retrieve OpenAI credentials from addon preferences."""
    try:
        addon_name = __package__ or os.path.basename(os.path.dirname(__file__))
        prefs = bpy.context.preferences.addons[addon_name].preferences
        api_key = prefs.api_key.strip()
        project = prefs.project_id.strip()
        org = prefs.organization_id.strip()
        return api_key, project, org
    except Exception:
        print("‚ö†Ô∏è Could not read OpenAI credentials from addon preferences.")
        return "", "", ""


def init_props():
    """Initialize custom Blender properties for GPT panel."""
    bpy.types.Scene.gpt4_chat_history = bpy.props.CollectionProperty(type=bpy.types.PropertyGroup)
    bpy.types.Scene.gpt4_model = bpy.props.EnumProperty(
        name="GPT Model",
        description="Select GPT model",
        items=[
            ("gpt-4o-mini", "GPT-4o-mini (fast)", ""),
            ("gpt-4o", "GPT-4o (standard)", ""),
            ("gpt-3.5-turbo", "GPT-3.5 Turbo", ""),
        ],
        default="gpt-4o-mini",
    )
    bpy.types.Scene.gpt4_chat_input = bpy.props.StringProperty(
        name="Message",
        description="Enter your message for GPT",
        default=""
    )
    bpy.types.Scene.gpt4_button_pressed = bpy.props.BoolProperty(default=False)
    bpy.types.PropertyGroup.type = bpy.props.StringProperty()
    bpy.types.PropertyGroup.content = bpy.props.StringProperty()


def clear_props():
    """Remove GPT-related properties from Blender scene."""
    del bpy.types.Scene.gpt4_chat_history
    del bpy.types.Scene.gpt4_chat_input
    del bpy.types.Scene.gpt4_button_pressed


def generate_blender_code(prompt, chat_history, context, system_prompt):
    """Generate Blender Python code using OpenAI API."""
    api_key, project, org = get_openai_credentials()
    if not api_key or not project:
        print("‚ùå Missing API key or project ID.")
        return None

    try:
        client = OpenAI(api_key=api_key, project=project, organization=org or None)
        print(f"üîë Connected to OpenAI Project: {project}")
    except Exception as e:
        print(f"‚ùå OpenAI initialization error: {e}")
        return None

    # Build the conversation context
    messages = [{"role": "system", "content": system_prompt}]
    for msg in chat_history[-10:]:
        if msg.type == "assistant":
            messages.append({"role": "assistant", "content": f"```\n{msg.content}\n```"})
        else:
            messages.append({"role": msg.type.lower(), "content": msg.content})

    messages.append({
        "role": "user",
        "content": f"Please write valid Blender Python code for this task: {prompt}. Return only code inside ```."
    })

    try:
        # Request completion from OpenAI
        response = client.chat.completions.create(
            model=context.scene.gpt4_model,
            messages=messages
        )

        text = response.choices[0].message.content
        code_blocks = re.findall(r'```(.*?)```', text, re.DOTALL)

        if not code_blocks:
            print("‚ö†Ô∏è No code block found in GPT response.")
            return None

        # Clean the code
        code = re.sub(r'^python', '', code_blocks[0], flags=re.MULTILINE)
        print("‚úÖ Code successfully generated by GPT.")
        return code.strip()

    except Exception as e:
        print(f"‚ùå OpenAI request failed: {e}")
        return None


def split_area_to_text_editor(context):
    """Open a new split area in Blender and set it to Text Editor."""
    area = context.area
    for region in area.regions:
        if region.type == 'WINDOW':
            override = {'area': area, 'region': region}
            bpy.ops.screen.area_split(override, direction='VERTICAL', factor=0.5)
            break

    new_area = context.screen.areas[-1]
    new_area.type = 'TEXT_EDITOR'
    return new_area
